<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Ejercicios (1). Docker. Aplicaciones web. Bartolomé Sintes Marco. www.mclibre.org</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../varios/webapps.css" title="mclibre">
  <link rel="icon" href="../varios/favicon.ico">
  <link rel="stylesheet" href="../varios/prism-webapps.css">
  <script src="../varios/prism.js"></script>
</head>

<body>
  <h1>Docker - Ejercicios (1) - Enunciados</h1>

  <nav>
    <p>
      <a href="../index.html"><img src="../varios/iconos/icono-webapps.svg" alt="Índice de WebApps" title="Índice de WebApps" width="48" height="31"></a>
      <a href="#"><img src="../varios/iconos/icono-arrow-circle-up.svg" alt="Principio de la página" title="Principio de la página" width="36" height="36"></a>
    </p>

    <div class="toc">
      <h2>
        <a href="docker.html"><img src="../varios/iconos/icono-flecha-izquierda.svg" alt="Anterior" title="Anterior" width="15" height="18"></a>
        <a href="docker-2.html"><img src="../varios/iconos/icono-flecha-derecha.svg" alt="Siguiente" title="Siguiente" width="15" height="18"></a>
        Docker (1)
      </h2>

      <h3><a href="#">Enunciados</a></h3>
      <ul>
        <li><a href="#ejercicio-1">1 - Instalar Docker</a></li>
        <li><a href="#ejercicio-2">2 - Imagen hello-world</a></li>
        <li><a href="#ejercicio-3">3 - Imagen Apache</a></li>
        <li><a href="#ejercicio-4">4 - Volúmenes</a>
          <ul>
            <li><a href="#ejercicio-4-bind">Directorio enlazado</a></li>
            <li><a href="#ejercicio-4-volume">Volúmenes</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </nav>

  <p>Esta lección es una introducción a la instalación de aplicaciones mediante <strong>Docker</strong>, utilizando las imágenes proporcionadas por Bitnami. Los ejercicios están planteados como actividades guiadas, por lo que no se ofrece una página de soluciones.</p>

  <section id="ejercicio-1">
    <h2>Docker (1) 1 - Instalar Docker</h2>

    <p>En este ejercicio instalaremos Docker en una máquina virtual de Ubuntu 18.04.3 LTS Server ejecutada en VirtualBox.</p>

    <p>Estas instrucciones se han extraído de la documentación oficial de Docker <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Install Docker on Ubuntu</a></p>

    <h3>Prepare la máquina virtual</h3>

    <p>Si ha realizado los <a href="packer-1.html">ejercicios de Packer</a> de estos apuntes, puede utilizar la máquina virtual creada en el <a href="packer-1.html#provisioners-script">ejercicio 1-3</a>, importándola en VirtualBox como servicio virtualizado.</p>

    <p>Si no se han realizado esos ejercicios, puede descargar la <a href="https://www.mclibre.org/descargar/webapps/1920/packer-2-1-ubuntu-18-04-3-server.ova">Máquina virtual VirtualBox (OVA) de Ubuntu 18.04.3, actualizada al 7 de enero de 2020 (07/01/20, 888 MB)</a> que contiene la máquina virtual creada en el <a href="packer-1.html#creacion-vm-vbox-ubuntu-manual">ejercicio Packer (1) 1</a> y comprimida de acuerdo con el <a href="packer-2.html#compresion">ejercicio Packer (2) 5</a>.</p>

    <p>Si quiere crear usted mismo la máquina virtual:</p>
    <ol>
      <li>Descargue la imagen iso de la versión más reciente de <strong>Ubuntu 18.04 LTS Server de 64 bits</strong>. Actualmente (diciembre de 2019), la última versión disponible de Ubuntu LTS Server es Ubuntu 18.04.3 (publicada el 08/08/19).
        <p>Para descargar la imagen .iso de instalación de Ubuntu Server 18.04.3 LTS puede utilizar:</p>
        <ul>
          <li>La página de descarga oficial <a href="http://cdimage.ubuntu.com/releases/18.04/release/">http://cdimage.ubuntu.com/releases/18.04/release/</a>. En esta página encontrará siempre la última versión publicada.</li>
          <li>Este enlace directo de descarga desde ubuntu, que seguramente dejará de estar disponible cuando se publique una nueva versión: <a href="http://cdimage.ubuntu.com/releases/18.04/release/ubuntu-18.04.3-server-amd64.iso">Ubuntu 18.04.3 Server</a> (08/08/19, 900 MB).</li>
          <li>Este enlace directo de descarga desde mclibre: <a href="https://www.mclibre.org/descargar/webapps/1920/ubuntu-18.04.3-server-amd64.iso">Ubuntu 18.04.3 Server</a> (08/08/19, 900 MB).</li>
        </ul>
      </li>
      <li>Cree una máquina virtual en VirtualBox e instale Ubuntu 18.04.3 LTS Server.
        <p>Para los ejercicios de esta página un disco duro virtual de 8 GB es suficiente, pero para poder instalar más aplicaciones se necesitaría un disco mayor, por ejemplo de <strong>16 GB</strong>.</p>
        <p>Compruebe que en la configuración de red de la máquina virtual está conectado a <strong>Adaptador puente</strong>. Si está conectado a otro tipo de adaptador (probablemente NAT), apague la máquina virtual, cambie a Adaptador puente y reinicie la máquina virtual.</p>
      </li>
    </ol>

    <h3>Actualice la distribución</h3>

    <p>Arranque la máquina virtual y ejecute los comandos siguientes en un terminal:</p>

    <ol>
      <li>Actualice la distribución:

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt update
sudo apt full-upgrade</code>
</pre>
        </div>
      </li>
    </ol>

    <h3>Instale utilidades</h3>

    <p>Instale las utilidades siguientes:</p>

    <ol>
      <li>Instale el editor nano:

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt install nano</code>
</pre>
        </div>
      </li>
    </ol>

    <h3>Añada los repositorios de Docker</h3>

    <p>En la máquina virtual, ejecute los comandos siguientes en un terminal:</p>

    <ol>
      <li>Instale los certificados para trabajar con https:

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common</code>
</pre>
        </div>
      </li>
      <li>Añada la clave GPG oficial de Docker:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code>
</pre>
        </div>
      </li>
      <li>Compruebe que tiene la clave correcta:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt-key fingerprint 0EBFCD88</code>
</pre>
        </div>
        <p>El resultado debe ser:</p>
        <div class="terminal">
          <pre>
<code class="language-shell">pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid        [desconocida] Docker Release (CE deb) &lt;docker@docker.com&gt;
sub   rsa4096R 2017-02-22 [S]</code>
</pre>
        </div>
      </li>
      <li>Añada el repositorio correspondiente a su versión de Ubuntu (escriba todo en una sola línea, sin las contrabarras \):
        <div class="terminal">
          <pre class="command-line" data-prompt="$" data-output="2-4">
<code class="language-shell">sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"</code>
</pre>
        </div>
      </li>
      <li>Actualice APT:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt update</code>
</pre>
        </div>
      </li>
      <li>Compruebe que APT se conecta con el repositorio adecuado:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">apt policy docker-ce</code></pre>
        </div>
        <p>En la pantalla debe mostrarse el repositorio de la versión de Docker disponible para la versión de Ubuntu indicada (en el ejemplo se muestran la versión de Docker 18.09.1 y la versión de Ubuntu bionic, es decir, Ubuntu 18.04):</p>
        <div class="terminal">
          <pre>
<code class="language-shell">docker-ce:
  Instalados: (ninguno)
  Candidato: 5:<span class="codigo-resaltado">19.03.5</span>~3-0~<span class="codigo-resaltado">ubuntu-bionic</span>
  Tabla de versión:
  5:19.03.5~3-0~ubuntu-bionic 500
          500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
...</code>
</pre>
        </div>
      </li>
    </ol>

    <h3>Instale Docker</h3>

    <p>En la máquina virtual, ejecute los comandos siguientes en un terminal:</p>

    <ol>
      <li>Actualice el administrador de paquetes:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt update</code>
</pre>
        </div>
      </li>
      <li>Instale la última versión de Docker
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo apt install docker-ce</code>
</pre>
        </div>
      </li>
      <li>Arranque el servicio docker
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo systemctl start docker</code>
</pre>
        </div>
      </li>
      <li>Compruebe que el servicio está activo:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">systemctl status docker</code>
</pre>
        </div>
        <p>Se mostrará un mensaje similar a este (pulse Ctrl+C para salir del texto):</p>
        <div class="terminal">
          <pre>
<code class="language-shell">&bull; docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: <span class="codigo-resaltado" style="color: #00ff00">active (running)</span> since ...
...</code>
</pre>
        </div>
      </li>
    </ol>
  </section>

  <section id="ejercicio-2">
    <h2>Docker (1) 2 - Imagen hello-world</h2>

    <p>Dos conceptos fundamentales de Docker son los <strong>contenedores</strong> y las <strong>imágenes</strong>.</p>

    <p>Docker encapsula las aplicaciones en <strong>contenedores</strong>. Un contenedor es el equivalente a una máquina virtual de la virtualización clásica, pero mucho más ligera porque utiliza recursos del sistema operativo del <i>host</i>. Las aplicaciones de cada contenedor "ven" un sistema operativo, que puede ser diferente en cada contenedor, pero quien realiza el trabajo es el sistema operativo común que hay por debajo.</p>

    <p>Docker crea los contenedores a partir de <strong>imágenes</strong>. Las imágenes son una especie de plantillas que contienen como mínimo todo el software que necesita la aplicación para ponerse en marcha. Las imágenes se pueden crear a partir de otras imágenes más básicas incluyendo software adicional en forma de capas. Todos los contenedores creados a partir de una imagen contienen el mismo software, aunque en el momento de su creación se pueden personalizar algunos detalles.</p>

    <p>En la máquina virtual, ejecute los comandos siguientes en un terminal:</p>

    <ol>
      <li>Compruebe que inicialmente no hay ningún contenedor creado (la opción -a hace que se muestren también los contenedores detenidos, sin ella se muestran sólo los contenedor que estén en marcha):
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker ps -a</code>
</pre>
        </div>

        <p>o también</p>
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker container ls -a</code>
</pre>
        </div>

        <p>La respuesta, en forma de tabla, será la siguiente. La cabecera de la tabla ocupa dos líneas ya que es una tabla con muchos campos.</p>

        <div class="terminal">
          <pre>
<code class="language-shell">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
PORTS               NAMES</code>
</pre>
        </div>
      </li>
      <li>Compruebe que inicialmente tampoco disponemos de ninguna imagen:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker image ls</code>
</pre>
        </div>
        <p>La respuesta, en forma de tabla, será la siguiente:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</code>
</pre>
        </div>
      </li>

      <li>Docker crea los contenedores a partir de imágenes locales (ya descargadas), pero si al crear el contenedor no se dispone de la imagen local, Docker descarga la imagen de su repositorio.

        <p>La orden más simple para crear un contenedor es:</p>
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker run IMAGEN</code>
</pre>
        </div>

        <p>Cree un contenedor con la aplicación de ejemplo <strong>hello-world</strong>. La imagen de este contenedor se llama <strong>hello-world</strong>:</p>
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker run hello-world</code>
</pre>
        </div>

        <p>Como no tenemos todavía la imagen en nuestro ordenador, Docker descarga la imagen, crea el contenedor y lo pone en marcha. En este caso, la aplicación que contiene el contenedor hello-world simplemente escribe un mensaje de salida al arrancar e inmediatamente se detiene el contenedor. La respuesta será similar a esta:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete
Digest: sha256:4fe721ccc2e8dc7362278a29dc660d833570ec2682f4e4194f4ee23e415e1064
Status: Download newer image from hello-wolrd:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.
...</code>
</pre>
        </div>
      </li>
      <li>Si listamos ahora las imágenes existentes ...

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker image ls</code>
</pre>
        </div>
        <p>... se mostrará información de la imagen creada:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              fce209e99eb9        4 weeks ago         1.84 kB</code>
</pre>
        </div>
      </li>
      <li>Si listamos ahora los contenedores existentes ...
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker ps -a</code>
</pre>
        </div>
        <p>... se mostrará información del contenedor creado:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
PORTS               NAMES
614B4c431ffa        hello-world         "/hello"            2 minutes ago       Exited (0) 2 minutes
ago                 hopeful_elbakyan</code>
</pre>
        </div>
        <p>Cada contenedor tiene un identificador (ID) y un nombre distinto. Docker "bautiza" los contenedores con un nombre peculiar, compuesto de un adjetivo y un apellido.</p>
      </li>
      <li>Podemos crear tantos contenedores como queramos a partir de una imagen. Una vez la imagen está disponible localmente, Docker no necesita descargarla y el proceso de creación del contenedor es inmediato (aunque en el caso de hello-world la descarga es rápida, con imágenes más grandes la descarga inicial puede tardar un rato)

        <p>Normalmente se aconseja usar siempre la opción <strong>-d</strong>, que arranca el contenedor en segundo plano (<i>detached</i>) y permite seguir teniendo acceso a la shell (aunque con hello-world no es estrictamente necesario porque el contenedor hello-world se detiene automáticamente tras mostrar el mensaje).</p>

        <p>Al crear el contenedor hello-world con la opción -d no se muestra el mensaje, simplemente muestra el identificador completo del contenedor.</p>

        <div class="terminal">
          <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d hello-world
1ae54736196021523a2b21c123fd671253e62150daccd882374</code>
</pre>
        </div>
      </li>
      <li>Si listamos los contenedores existentes ...

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker ps -a</code>
</pre>
        </div>
        <p>... se mostrarán los dos contenedores:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
PORTS               NAMES
1ae547361960        hello-world         "/hello"            4 seconds ago       Exited (0) 3 seconds
ago                 distracted_banach
614B4c431ffa        hello-world         "/hello"            5 minutes ago       Exited (0) 5 minutes
ago                 hopeful_elbakyan</code>
</pre>
        </div>
      </li>
      <li>Los contenedores se pueden destruir mediante el comando <i>rm</i>, haciendo referencia a ellos mediante su nombre o su id. No es necesario indicar el id completo, basta con escribir los primeros carácteres (de manera que no haya ambigüedades). Borre los dos contenedores existentes:
        <div class="terminal">
          <pre class="command-line" data-prompt="$" data-output="2, 4">
<code class="language-shell">sudo docker rm 1ae
1ae
sudo docker rm hopefukl_elbakyan
hopefukl_elbakyan</code>
</pre>
        </div>
        <p>Compruebe que ya no quedan contenedores:</p>

        <div class="terminal">
          <pre class="command-line" data-prompt="$" data-output="2-3">
<code class="language-shell">sudo docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
PORTS               NAMES</code>
</pre>
        </div>
      </li>
      <li>Podemos dar nombre a los contenedores al crearlos:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker run -d --name=hola-1 hello-world</code>
</pre>
        </div>

        <p>Al haber utilizado la opción -d únicamente se mostrará el ID completo del contenedor:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">54e9827bd10ab2825e1b3e4d3bf7a8cbdf778b472359c655d72d9c09e753500a</code>
</pre>
        </div>
      </li>
      <li>Si listamos los contenedores existentes ...

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker ps -a</code>
</pre>
        </div>
        <p>... se mostrará el contenedor con el nombre que hemos indicado:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
PORTS               NAMES
54e9827bd10a        hello-world         "/hello"            4 seconds ago       Exited (0) 3 seconds
ago                 <span class="codigo-resaltado">hola-1</span></code>
</pre>
        </div>
      </li>
      <li>Si intentamos crear un segundo contenedor con un nombre ya utilizado ...
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker run -d --name=hola-1 hello-world</code>
</pre>
        </div>

        <p>Docker nos avisará de que no es posible:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">docker: Error response from daemon: Conflict. The container <span class="codigo-resaltado">name "/hola-1" is already in use</span> by con
tainer "54e9827bd10ab2825e1b3e4d3bf7a8cbdf778b472359c655d72d9c09e753500a". You have to remove (or re
name) that container to be able to reuse that name.
See 'docker run --help'.</code>
</pre>
        </div>
      </li>
    </ol>
  </section>

  <section id="ejercicio-3">
    <h2>Docker (1) 3 - Imagen apache</h2>

    <p>En este ejercicio vamos a crear un contenedor que incluya un servidor Apache en funcionamiento a partir de una imagen pública, modificar el contenido del contenedor y finalmente, crear una nueva imagen para crear contenedores personalizados.</p>

    <h3>Crear el contenedor Apache</h3>
    <ol>
      <li>Cree un contenedor que contenga un servidor Apache a partir de la imagen <a href="https://github.com/bitnami/bitnami-docker-apache">bitnami/apache</a>
        <p>la opción -P hace que Docker asigne de forma aleatoria un puerto de la máquina virtual al puerto asignado a Apache en el contenedor. La imagen bitnami/apache asigna a Apache el puerto 8080 del contenedor para conexiones http y el puerto 8443 para conexiones https.</p>
        <div class="terminal">
          <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d -P --name=apache-1 bitnami/apache
44c9e89bdfd24fa623774b3e774b0fb0efa107f752af5161b1d6b925330a82f6</code>
</pre>
        </div>
      </li>

      <li>Consulte el puerto del <i>host</i> utilizado por el contenedor ...

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker ps -a</code>
</pre>
        </div>
        <p>... se mostrará el contenedor con el nombre que hemos indicado:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS
      PORTS                                              NAMES
44c9e89bdfd2        bitnami/apache      "/app-entrypoint.sh &hellip;"   About a minute ago       Up About a min
ute   0.0.0.:<span class="codigo-resaltado">32769-&gt;8080</span>/tcp, 0.0.0.0:<span class="codigo-resaltado">32768-&gt;8443</span>/tcp   apache-1</code>
</pre>
        </div>
      </li>
      <li>Abra en el navegador la página inicial del contenedor y compruebe que se muestra una página que dice "It works!".
        <p class="captura">
          <img src="../img/docker/1-3-e-1-apache.png" alt="Docker. Apache" width="1024" height="150">
        </p>
      </li>
    </ol>

    <h3>Modificar la página inicial del contenedor Apache</h3>

    <p>En este apartado vamos a modificar la página web inicial de Apache del contenedor Docker.</p>

    <p>Tenga en cuenta que modificar el contenido de un contenedor tal y como vamos a hacer en este apartado sólo es aconsejable en un entorno de desarrollo, pero no es aconsejable en un entorno de producción porque va en contra de la "filosofía" de Docker. Los contenedores de Docker están pensados como objetos de "usar y tirar", es decir, para ser creados, destruidos y creados de nuevo tantas veces como sea necesario y en la cantidad que sea necesaria. En el apartado siguiente realizaremos la misma tarea de una forma más conveniente, modificando no el contenedor sino la imagen a partir de la cual se crean los contenedores.</p>

    <ol>
      <li>Cree un segundo contenedor que contenga un servidor Apache a partir de la imagen <a href="https://github.com/bitnami/bitnami-docker-apache">bitnami/apache</a>
        <div class="terminal">
          <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d -P --name=apache-2 bitnami/apache
c5041d12aabdc6f58219fec176036eb352ecaea7cf81b8f7fa2ad8af801c96a2</code>
</pre>
        </div>
      </li>

      <li>Consulte el puerto del <i>host</i> utilizado por el contenedor ...

        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker ps -a</code>
</pre>
        </div>
        <p>... se mostrarán los dos contenedores creados:</p>

        <div class="terminal">
          <pre>
<code class="language-shell">CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS
      PORTS                                               NAMES
c5041d12aabd        bitnami/apache      "/app-entrypoint.sh &hellip;"   About a minute ago       Up About a min
ute    0.0.0.:<span class="codigo-resaltado">32771-&gt;8080</span>/tcp, 0.0.0.0:<span class="codigo-resaltado">32770-&gt;8443</span>/tcp   apache-2
44c9e89bdfd2        bitnami/apache      "/app-entrypoint.sh &hellip;"   5 minutes ago            Up 5 min
utes   0.0.0.:32769-&gt;8080/tcp, 0.0.0.0:32768-&gt;8443/tcp    apache-1</code>
</pre>
        </div>
      </li>
      <li>Cree la nueva página index.html ...
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo nano index.html</code>
</pre>
        </div>

        <p>... por ejemplo con el contenido siguiente</p>
        <div class="terminal">
          <pre>
<code class="language-shell">&lt;h1&gt;Hola, mundo!&lt;/h1&gt;</code>
</pre>
        </div>
        <p> ... o mejor, una página válida HTML5 (para poder escribir caracteres no ingleses):</p>
        <div class="terminal">
          <pre>
<code class="language-shell">&lt;!DOCTYPE html&gt;
&lt;html lang="es"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Apache en Docker&lt;/title&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;h1&gt;¡Hola, mundo!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</pre>
        </div>
      </li>

      <li>Entre en la <i>shell</i> del contenedor para averiguar la ubicación de la página inicial:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker exec -it apache-2 /bin/bash</code>
</pre>
        </div>
        <p>Se abrirá una <i>shell</i> en el contenedor. El DocumentRoot de Apache está en el directorio <strong>/opt/bitnami/apache/htdocs</strong></p>
        <div class="terminal">
          <pre>
<code class="language-shell">I have no name!@c5041d12aabd:<span class="codigo-resaltado">/opt/bitnami/apache/htdocs</span>$</code>
</pre>
        </div>
      </li>

      <li>En ese directorio se encuentra el fichero index.html que queremos modificar:
        <div class="terminal">
          <pre>
<code>cat index.html
<span class="codigo-resaltado">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></code>
</pre>
        </div>

      </li>
      <li>Salga de la shell del contenedor:
        <div class="terminal">
          <pre class="command-line" data-prompt="I have no name!@c5041d12aabd:/opt/bitnami/apache/htdocs$">
<code class="language-shell">exit</code>
</pre>
        </div>
      </li>

      <li>Copie el fichero index.html en el contenedor:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker cp index.html apache-2:/opt/bitnami/apache/htdocs/index.html</code>
</pre>
        </div>
      </li>
      <li>Abra en el navegador la página inicial del contenedor y compruebe que se ha modificado.
        <p class="captura">
          <img src="../img/docker/1-3-e-2-apache.png" alt="Docker. Apache" width="1024" height="160">
        </p>
      </li>
    </ol>

    <h3>Crear una nueva imagen</h3>

    <p><strong>Nota</strong>: Si queremos cambiar la página inicial, la forma correcta de hacerlo en Docker es crear una nueva imagen que incluya la página modificada, de manera que cada vez que se cree el contenedor, la página inicial sea la modificada.</p>

    <p>Las imágenes se crean a partir de Dockerfiles, ficheros que describen los elementos que forman la imagen. Los Dockerfiles pueden ser muy extensos. En este caso, se trata de un Dockerfile mínimo.</p>

    <ol>
      <li>Cree un directorio que contendrá el Dockerfile
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo mkdir mi-apache</code>
</pre>
        </div>
      </li>
      <li>Copie el fichero index.html creado anteriormente
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo mv index.html mi-apache</code>
</pre>
        </div>
      </li>
      <li>Entre en el directorio y cree un fichero Dockerfile
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">cd mi-apache
sudo nano Dockerfile</code>
</pre>
        </div>
        <p>El contenido del Dockerfile puede ser el siguiente:</p>
        <div class="terminal">
          <pre>
<code class="language-shell">FROM bitnami/apache
COPY index.html /opt/bitnami/apache/htdocs/index.html</code>
</pre>
        </div>
      </li>
      <li>Genere la nueva imagen.
        <p>El último argumento (y el único imprescindible) es el nombre del archivo Dockerfile que tiene que utilizar para generar la imagen. Como en este caso se encuentra en el mismo directorio y tiene el nombre predeterminado <strong>Dockerfile</strong>, se puede escribir simplemente punto (.).</p>
        <p>Para indicar el nombre de la imagen se debe añadir la opción -t. El nombre de la imagen debe seguir el patrón <strong>nombre-de-usuario/nombre-de-imagen</strong>. Si la imagen sólo se va a utilizar localmente, el nombre de usuario y de la imagen pueden ser cualquier palabra.</p>
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker build -t barto/mi-apache .</code>
</pre>
        </div>
      </li>
      <li>Cree un contenedor a partir de la nueva imagen:
        <div class="terminal">
          <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker run -d -P --name=mi-apache-1 barto/mi-apache</code>
</pre>
        </div>
      </li>
      <li>Abra en el navegador la página inicial del contenedor y compruebe que se ha modificado.
        <p class="captura">
          <img src="../img/docker/1-3-e-3-apache.png" alt="Docker. Apache" width="1024" height="160">
        </p>
      </li>
    </ol>
  </section>

  <section id="ejercicio-4">
    <h2>Docker (1) 4 - Volúmenes</h2>

    <p>Docker simplifica enormemente la creación de contenedores, y eso lleva a tratar los contenedores como un elemento efímero, que se crea cuando se necesita y que no importa que se destruya puesto que puede ser reconstruido una y otra vez a partir de su imagen.</p>

    <p>Pero si la aplicación o aplicaciones incluidas en el contenedor generan datos y esos datos se guardan en el propio contenedor, en el momento en que se destruyera el contenedor perderíamos esos datos. Para conseguir la persistencia de los datos, se pueden emplear dos técnicas:</p>
    <ul>
      <li>Los directorios enlazados, en la que la información se guarda fuera de Docker, en la máquina <i>host</i> (en nuestro caso, en la máquina virtual de Ubuntu)</li>
      <li>Los volúmenes, en la que la información se guarda mediante Docker, pero en unos elementos llamados <i>volúmenes</i>, independientes de las imágenes y los contenedores</li>
    </ul>

    <p>Los volúmenes son la mejor solución cuando la información es generada por el propio contenedor y los directorios enlazados pueden ser más adecuados cuando la información no es generada por ningún contenedor.</p>

    <section id="ejercicio-4-bind">
      <h3>Directorios enlazados (<i>bind</i>)</h3>

      <p>Docker permite asociar directorios del contenedor a directorios de la máquina <i>host</i> (en nuestro caso, de la máquina virtual de Ubuntu). Es decir, que cuando el contenedor lea o escriba en su directorio, donde leerá o escribirá será en el directorio de la máquina virtual.</p>

      <p>Si el directorio enlazado es el directorio en el que la aplicación guarda los datos generados por la propia aplicación, de esta manera conseguimos que los datos estén realmente fuera del contenedor. Eso significa que podemos conservar los datos aunque se destruya el contenedor, reutilizarlos con otro contenedor, etc.</p>

      <p>En este ejemplo, vamos a volver a aprovechar el hecho que la imagen bitnami/apache está configurada para que el directorio htdocs habitual (en el caso de bitnami como hemos visto en el ejercicio anterior es <strong>/opt/bitnami/apache/htdocs</strong>) enlace al directorio <strong>/app</strong> [véase <a href="https://github.com/bitnami/bitnami-docker-apache/blob/master/2.4/debian-9/Dockerfile">Dockerfile de bitnami/apache</a>]</p>

      <p>Si al crear el contenedor enlazamos el directorio /app con un directorio de la máquina virtual, el contenedor servirá las páginas contenidas en el directorio de la máquina virtual.</p>

      <p>En la máquina virtual, ejecute los comandos siguientes en un terminal:</p>

      <ol>
        <li>Cree un directorio que contendrá las páginas web:
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo mkdir /home/barto/web</code>
</pre>
          </div>
        </li>

        <li>Cree un contenedor Apache.
          <p>La opción --mount permite crear el enlace entre el directorio de la máquina virtual y el contenedor. La opción tiene tres argumentos separados por comas pero sin espacios: type=bind,source=ORIGEN-EN-MÁQUINA-VIRTUAL,target=DESTINO-EN-CONTENEDOR. Ambos directorios deben existir previamente.</p>
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d -P --name=apache-bind-1 <span class="codigo-resaltado">--mount type=bind,source=/home/barto/web,target=/app</span> bitnami/apache
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</code>
</pre>
          </div>
        </li>

        <li>Abra en el navegador la página inicial del contenedor y compruebe que se muestra el contenido de un directorio vacío.
          <p class="captura">
            <img src="../img/docker/1-4-e-1-bind.png" alt="Docker. Apache" width="1024" height="150">
          </p>
        </li>

        <li>Cree un fichero index.html:
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo nano /home/barto/web/index.html</code>
</pre>
          </div>

          <p>... por ejemplo con el contenido siguiente</p>
          <div class="terminal">
            <pre>
<code class="language-shell">&lt;h1&gt;Hola, amigo!&lt;/h1&gt;</code>
</pre>
          </div>
          <p> ... o mejor, una página válida HTML5 (para poder escribir caracteres no ingleses):</p>
          <div class="terminal">
            <pre>
<code class="language-shell">&lt;!DOCTYPE html&gt;
&lt;html lang="es"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Apache en Docker&lt;/title&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;h1&gt;¡Hola, amigo!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</pre>
          </div>
        </li>

        <li>Actualice el navegador y compruebe que se muestra la página recién creada.
          <p class="captura">
            <img src="../img/docker/1-4-e-2-bind.png" alt="Docker. Apache" width="1024" height="160">
          </p>
        </li>

        <li>Gracias a los directorios enlazados, podemos trabajar en la máquina virtual con los ficheros del directorio /web haya o no haya contenedores en marcha y al crear un contenedor, podremos acceder al contenido del directorio a través del servidor web del contenedor

          <p>Detenga y elimine el contenedor apache-bind-1:</p>
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker stop apache-bind-1
sudo docker rm apache-bind-1</code>
</pre>
          </div>
        </li>
        <li>Cree un nuevo contenedor que enlace al directorio /web:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d -P --name=apache-bind-2 --mount type=bind,source=/home/barto/web,target=/app bitnami/apache
5fd924625f6ab16a19cc9807c7c506ae1813490e4ba675f843d5a10e0baacdb8</code>
</pre>
          </div>
        </li>
        <li>Abra en el navegador la página inicial del nuevo contenedor y compruebe que se muestra la página que está en la máquina virtual.
          <p class="captura">
            <img src="../img/docker/1-4-e-3-bind.png" alt="Docker. Apache" width="1024" height="160">
          </p>
        </li>

      </ol>

      <hr class="corta">

      <p><strong>Nota</strong>: La imagen bitnami/apache incluye un directorio /app que enlaza a /opt/bitnami/apache/htdocs como puede comprobar entrando en el contenedor:</p>
      <ol>
        <li>Entre en la <i>shell</i> del contenedor:
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker exec -it apache-bind-1 /bin/bash</code>
</pre>
          </div>
        </li>
        <li>Liste los directorios en la raíz del contenedor:
          <div class="terminal">
            <pre class="command-line" data-prompt="I have no name!@e3b0c44298fc:$">
<code class="language-shell">ls -al /</code>
</pre>
          </div>
        </li>
        <li>Compruebe que el directorio /app enlaza al directorio /opt/bitnami/apache/htdocs:
          <div class="terminal">
            <pre>
<code class="language-shell">total 112
drwxr-xr-x  1 root root 4096 Feb  6 22:37 .
drwxr-xr-x  1 root root 4096 Feb  6 22:37 ..
-rwxr-xr-x  1 root root    0 Feb  6 22:37 .dockerenv
drwxrwxr-x  1 root root 4096 Jan 30 10:50 .nami
-rw-rw-r--  1 root root  118 Jan 30 10:50 apache-inputs.json
<span class="codigo-resaltado">lrwxrwxrwx  1 root root   26 Jan 30 10:50 app -&gt; /opt/bitnami/apache/htdocs</span>
...</code>
</pre>
          </div>
        </li>
      </ol>
    </section>

    <section id="ejercicio-4-volume">
      <h3>Volúmenes (<i>volume</i>)</h3>

      <p>En vez de guardar los datos persistentes en la máquina <i>host</i>, Docker dispone de unos elementos llamados volúmenes que podemos asociar también a directorios del contenedor, de manera que cuando el contenedor lea o escriba en su directorio, donde leerá o escribirá será en el volumen.</p>

      <p>Los volúmenes son independientes de los contenedores, por lo que también podemos conservar los datos aunque se destruya el contenedor, reutilizarlos con otro contenedor, etc. La ventaja frente a los directorios enlazados es que pueden ser gestionados por Docker. Otro detalle importante es que el acceso al contenido de los volúmenes sólo se puede hacer a través de algún contenedor que utilice el volumen.</p>

      <p>Vamos a repetir un ejemplo similar al ejemplo anterior, pero utilizando un volumen en vez de un directorio enlazado. En este caso, enlazaremos el directorio /app con un volumen de Docker. directorio de la máquina virtual, el contenedor servirá las páginas contenidas en el directorio de la máquina virtual.</p>

      <p>En la máquina virtual, ejecute los comandos siguientes en un terminal:</p>

      <ol>
        <li>Cree un contenedor Apache.
          <p>La opción --mount permite crear el volumen . La opción tiene tres argumentos separados por comas pero sin espacios: type=volume,source=NOMBRE-DEL-VOLUMEN,target=DESTINO-EN-CONTENEDOR. El directorio de destino debe existir previamente.</p>
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d -P --name=apache-volume-1 <span class="codigo-resaltado">--mount type=volume,source=vol-apache,target=/app</span> bitnami/apache
3b1bcc5a67f38853810972b1da8a67148fad78c6cd6f22b2c823d141be59c81c</code>
</pre>
          </div>
        </li>

        <li>Compruebe que se ha creado el contenedor y consulte el puerto asignado:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-5">
<code class="language-shell">sudo docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS
      PORTS                                              NAMES
3b1bcc5a67f3        bitnami/apache      "/app-entrypoint.sh &hellip;"   About a minute ago       Up About a min
ute   0.0.0.:<span class="codigo-resaltado">32769-&gt;8080</span>/tcp, 0.0.0.0:<span class="codigo-resaltado">32768-&gt;8443</span>/tcp   apache-volume-1</code>
</pre>
          </div>
        </li>

        <li>Abra en el navegador la página inicial del contenedor y compruebe que se muestra la página inicial habitual de esta imagen.
          <p class="captura">
            <img src="../img/docker/1-4-e-11-volume.png" alt="Docker. Apache" width="1024" height="150">
          </p>
        </li>

        <li>Compruebe que se ha creado un volumen con el nombre asignado al crear el contenedor:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-3">
<code class="language-shell">sudo docker volume ls
DRIVER              VOLUME NAME
local               <span class="codigo-resaltado">vol-apache</span></code>
</pre>
          </div>
        </li>

        <li>Los volúmenes son entidades independientes de los contenedores, pero para acceder al contenido del volumen hay que hacerlo a través contenedor, más exactamente a través del directorio indicado al crear el contenedor.
          <p>Entre en el contenedor y liste el directorio /app.</p>
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-3">
<code class="language-shell">sudo docker exec -it apache-volume-1 /bin/bash
I have no name!@3b1bcc5a67f3:$ ls /app
index.html</code>
</pre>
          </div>

          <p>El directorio /app contiene únicamente el fichero index.html. Pero tenga en cuenta que la página web index.html se encuentra en el volumen, no en el contenedor.</p>
        </li>

        <li>Modifique esa página web. Para ello, salga del contenedor`:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="0">
<code class="language-shell">I have no name!@3b1bcc5a67f3:$ exit
</code>
</pre>
          </div>
        </li>
        <li>
          <p>... y cree un nuevo fichero index.html:</p>
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo nano index.html</code>
</pre>
          </div>
        </li>
        <li>Por ejemplo, con el siguiente contenido:
          <div class="terminal">
            <pre>
<code class="language-shell">&lt;h1&gt;Hola de nuevo, amigo!&lt;/h1&gt;</code>
</pre>
          </div>
          <p> ... o mejor, una página válida HTML5 (para poder escribir caracteres no ingleses):</p>
          <div class="terminal">
            <pre>
<code class="language-shell">&lt;!DOCTYPE html&gt;
&lt;html lang="es"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Apache en Docker&lt;/title&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;h1&gt;¡Hola de nuevo, amigo!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</pre>
          </div>
        </li>

        <li>Copie el fichero index.html en el directorio /app del contenedor (aunque realmente se copiará en el volumen):
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker cp index.html apache-volume-1:app/</code>
</pre>
          </div>
        </li>

        <li>Actualice el navegador y compruebe que se muestra la página recién creada.
          <p class="captura">
            <img src="../img/docker/1-4-e-12-volume.png" alt="Docker. Apache" width="1024" height="160">
          </p>
        </li>

        <li>Cree ahora un nuevo contenedor que use el mismo volumen:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker run -d -P <span class="codigo-resaltado">--name=apache-volume-2</span> <span class="codigo-resaltado">--mount type=volume,source=vol-apache,target=/app</span> bitnami/apache
a6c8a30f7b1dc7a4ef165046daff226ee1d6a69573269ca24d57b5b4b6802881</code>
</pre>
          </div>
        </li>

        <li>Compruebe que se ha creado el contenedor y consulte el puerto asignado:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-5">
<code class="language-shell">sudo docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS
     PORTS                                              NAMES
a6c8a30f7b1d        bitnami/apache      "/app-entrypoint.sh &hellip;"   About a minute ago       Up About a min
ute  0.0.0.:<span class="codigo-resaltado">32771-&gt;8080</span>/tcp, 0.0.0.0:<span class="codigo-resaltado">32770-&gt;8443</span>/tcp   apache-volume-2
3b1bcc5a67f3        bitnami/apache      "/app-entrypoint.sh &hellip;"   5 minutes ago            Up 5 minutes
     0.0.0.:32769-&gt;8080/tcp, 0.0.0.0:32768-&gt;8443/tcp   apache-volume-1</code>
</pre>
          </div>
        </li>
        <li>Abra en el navegador la página inicial del nuevo contenedor y compruebe que este contenedor muestra también la página que ha copiado antes en el volumen.
          <p class="captura">
            <img src="../img/docker/1-4-e-13-volume.png" alt="Docker. Apache" width="1024" height="160">
          </p>
        </li>
      </ol>

      <hr class="corta">

      <p>Los volúmenes son independientes de los contenedores, pero Docker tiene en cuenta qué volúmenes están siendo utilizados por un contenedor.</p>
      <ol>
        <li>Si intenta borrar el volumen del ejemplo anterior mientras los contenedores están en marcha, Docker muestra un mensaje de error que indica los contenedores afectados:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-3">
<code class="language-shell">sudo docker volume rm vol-apache
Error response from daemon: remove vol-apache: <span class="codigo-resaltado">volume is in use</span> - [a6c8a30f7b1dc7a4ef165046daff226ee
1d6a69573269ca24d57b5b4b6802881, 3b1bcc5a67f38853810972b1da8a67148fad78c6cd6f22b2c823d141be59c81c]</code>
</pre>
          </div>
        </li>
        <li>Detenga los contenedores:
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker stop apache-volume-1
sudo docker stop apache-volume.2</code>
</pre>
          </div>
        </li>
        <li>Si intenta de nuevo borrar el volumen del ejemplo anterior ahora que los contenedores están detenidos, Docker sigue mostrando el mensaje de error que indica los contenedores afectados:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-3">
<code class="language-shell">sudo docker volume rm vol-apache
Error response from daemon: remove vol-apache: <span class="codigo-resaltado">volume is in use</span> - [a6c8a30f7b1dc7a4ef165046daff226ee
1d6a69573269ca24d57b5b4b6802881, 3b1bcc5a67f38853810972b1da8a67148fad78c6cd6f22b2c823d141be59c81c]</code>
</pre>
          </div>
        </li>
        <li>Borre los contenedores:
          <div class="terminal">
            <pre class="command-line" data-prompt="$">
<code class="language-shell">sudo docker rm apache-volume-1
sudo docker rm apache-volume.2</code>
</pre>
          </div>
        </li>
        <li>Si intenta de nuevo borrar el volumen del ejemplo anterior ahora que no hay contenedores que utilicen el volumen, Docker ahora sí que borrará el volumen:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2">
<code class="language-shell">sudo docker volume rm vol-apache
vol-apache</code>
</pre>
          </div>
        </li>

        <li>Compruebe que el volumen ya no existe:
          <div class="terminal">
            <pre class="command-line" data-prompt="$" data-output="2-3">
<code class="language-shell">sudo docker volume ls
DRIVER              VOLUME NAME</code>
</pre>
          </div>
          <p>Tenga en cuenta que al borrar un volumen, los datos que contenía el volumen se pierden para siempre, salvo que hubiera realizado una copia de seguridad.</p>
        </li>
      </ol>
    </section>
  </section>

  <footer>
    <p class="ultmod">Última modificación de esta página: 7 de enero de 2020</p>

    <p class="licencia">
      <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES"><img src="../varios/iconos/icono-cc-by-sa.svg" alt="Licencia Creative Commons" title="Licencia Creative Commons BY-SA" width="120" height="42"></a><br>
      Esta página forma parte del curso <strong><a href="https://www.mclibre.org/consultar/webapps/">Aplicaciones web</a></strong> por <a href="https://www.mclibre.org/" rel="author">Bartolomé Sintes Marco</a><br>
      que se distribuye bajo una <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES">Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)</a>.
    </p>
  </footer>
</body>
</html>
